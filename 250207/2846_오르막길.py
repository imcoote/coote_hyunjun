#수열의 길이 N, N안의 값은 Pi 양의 정수
N= int(input())
Pi =list(map(int, input().split()))


cnt=0
min_num=0
end_num=0
height=0
#예를 들어, 높이가 다음과 같은 길이 있다고 하자.
# 12 3 5 7 10 6 1 11. 이 길에는 2 개의 오르막길이 있다.
# 밑 줄로 표시된 부분 수열이 오르막길이다.
# 첫 번째 오르막길의 크기는 7이고, 두 번째 오르막길의 크기는 10이다.
# 높이가 12와 6인 곳은 오르막길에 속하지 않는다.

#가장 큰 오르막길을 구하는 프로그램을 작성하시오.


# 가장 큰 오르막길을 구하려면 수열이 연속되는 오르막 구간을 알아야한다.
# 반복문을 N만큼 돌리면서 i번쨰와 i+1을 비교해서 i <i+1 이면 오르막이다.

# 12 3 5 7 10 6 1 11 을 예시로 들었을떄
# i=12, i+1=3
# 12가 더 크니까 다음으로 넘어간다.
#
# i=3 , i+1 = 5 3<5이니까 3과 5를 저장해놓는다.
# i=5, i+1=7 5<7 이니까 5를 7로 대체한다.
# i=7, i+1=10 7<10 이니까 7을 10으로 대체한다.
# i=10, i+1=6 이면 i>i+1 , 즉 i값이 더크므로
# 맨 처음 저장했던 3과 마지막으로 저장한 10의 차를 구하고 저장하고 넘어간다.
#
# 두가지 경우의 수를 먼저 정의하자

while cnt < N-1: # 수열의길이만큼 반복하도록 설정 , cnt+1을 실행해야하니 index오류가 나지않도록 N-1 까지
    if cnt==0 :
        min_num = Pi[cnt] # cnt=0인 첫번쨰 실행일때 첫번쨰 값을 저장

    if Pi[cnt] < Pi[cnt+1]: # 오름차순이라면
        min_num=min(min_num,Pi[cnt]) # min넘버 저장 하고.
        end_num=max(end_num,Pi[cnt+1]) # max
        # min과 비교하여 더 작은것을 저장하자.
    else: # 오름차순이 아니라면
        #이전의 결과를 저장하고 값들을 초기화 해줘야 할것.
        #그럼 일단 이전결과 저장
        if height < end_num - min_num: # 오르막의 높이를 비교해서 더 큰값을 height에 저장하는 if문.
            height = end_num - min_num
        #저장해줬으니 이제 min 와 end 를 초기화
        min_num = Pi[cnt]
        end_num = Pi[cnt+1]
    cnt += 1

# 마지막 오르막길 반영 (배열 끝까지 오르막일 경우)
height = max(height, end_num - min_num)

print(height)




